[Think Stats Chapter 4 Exercise 2](http://greenteapress.com/thinkstats2/html/thinkstats2005.html#toc41) (a random distribution)

>> Are numbers generated by the function `random.random` really random? To answer this question, let's import the `random` module and generate a sufficiently large sample--1000 numbers--using the `random` function. 
```
import random
# Generate 1000 random numbers:
sample = [random.random() for x in range(0, 1000)]
```
>> We can now figure out whether each number in the sample has been generated with equal probability, or whether certain numbers have come about more often. If `random.random` *is* random, every number will be generated with an equal probability; for 1000 numbers, an equal probability for each number would be 1/1000, or 0.001, per number. A probability mass function (PMF), mapping values to probabilities for a given group of values, will tell us precisely this information.
```
# Generate PMF for sample:
sample_pmf = thinkstats2.Pmf(sample)
```
>> Plotting `sample_pmf` (using `thinkstats2.thinkplot`) will allow us a clear visual representation of the probabilistic distribution of values in the sample.
```
# Plot sample_pmf:
thinkplot.PrePlot(1)
thinkplot.SubPlot(1)
thinkplot.Pmfs([sample_pmf])
thinkplot.Show(xlabel='random number',
               ylabel='probability',
               axis=[0, 1, 0, 0.002])
```
>> <a href="https://github.com/bellentuck/dsp/commit/ab6acdb0c5c688c482a9c9d0a80d20756e261eea?diff=unified"><img src="img/thinkstats_random_numbers_pmf.png" style="width: 100px;" target="_blank"></a>
>> According to the PMF graph above, `random.random` is random because the distribution of values is uniform. Specifically, each value has a 1/1000 chance to come up. In other words, `random.random` appears to have generated a different random number from 0-1 (not including 0) every time.

>> So, in a narrow sense `random.random` is random. How about in the broader sense of generating numbers of any sort of size with equal probability? For `random.random` to be random in this sense, numbers will be randomly generated such that there is no "bunching" of numbers in particular sub-ranges between 0-1. 

>> The cumulative distribution function (CDF) allows us to discern whether some sub-ranges of random numbers between 0-1 contain more values than others in our sample. This is because, unlike a PMF which counts up to 1 by percentages, a CDF counts by percentiles. Since every percentile is equally large (1/100 of the overall sample range; e.g., 0.00-0.01, 0.01-0.02, etc.), a PMF will show us if percentile sub-ranges cluster around given values or not. (PMF orders the values in order to do this.)
```
# Generate CDF for sample:
sample_cdf = thinkstats2.Cdf(sample)
```
>> Let's visualize `sample_cdf` to gain an understanding of the distribution. If `random.random` is equally likely to generate a number in any percentile sub-range, our graph will be a straight line (i.e., it will have a constant slope) cutting diagonally up through the graph (i.e., it will go from the zeroth percentile to the ninety-ninth).
```
# Plot sample_cdf
thinkplot.PrePlot(1)
thinkplot.Cdfs([sample_cdf])
thinkplot.Show(xlabel='random number', ylabel='percentile')
```
>> <a href="https://github.com/bellentuck/dsp/commit/ab6acdb0c5c688c482a9c9d0a80d20756e261eea?diff=unified"><img src="img/thinkstats_random_numbers_cdf.png" style="width: 100px;" target="_blank"></a>
>> As we can see, the CDF graph line has a more or less constant slope. More or less: there are slight variations. Initially, these slight variations might suggest something like that evenly spacing out random numbers from one another is of only auxiliary concern to `random.random`: the primary concern of the function is to generate a different number every time the function gets called.

>> Put another way, however, `random.random` simply disregards concern for evenly-spacing numbers; to do so would be to impose a strange determinism upon the randomness (in other words it would make the random numbers "less" random, or even not "really" random, depending how you argue it). It then speaks to the viability of `random.random` as a random number generator that despite disregard for where numbers end up between 0-1, numbers still end up about evenly distributed across the 0-1 range.